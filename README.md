# OS course

## [Лабораторная работа 1](lab_1/README.md)

### Описание лабораторной
Вы имеете очень хорошую и правильную привычку создавать резервные
копии важных файлов. Резервные копии представляют собой архивы в
формате 7z, которые вы делаете еженедельно и сохраняете на внешнем
жестком диске.

&emsp; Однажды после создания очередной резервной копии вы подключили
внешний жесткий диск к компьютеру для переноса архива на нее и
обнаружили, что он не определяется системой. Вы передали жесткий диск в
компанию, занимающуюся восстановлением данных, и они смогли извлечь все
архивы, но метаданные, включая имена и даты создания архивов, были
безвозвратно утеряны. Имена файлов архивов представляют собой просто
числовые идентификаторы вида 0123456789.7z, присвоенные программой
восстановления данных в случайном порядке. Оперировать такой коллекцией
данных весьма неудобно. Однако вы знаете, что каждый последующий архив
немного больше предыдущего, потому что вы делали бекапы еженедельно в
один и тот же день недели, а также вам известна дата создания последнего из
архивов.

### Задание
Написать скрипт для PowerShell, который переименовывает файлы так,
чтобы архивы шли в том порядке, в котором они были реально созданы.
Скрипт представить в виде исполняемого файла с соответствующим
расширением. У скрипта должно быть два входных параметра: путь до папки
с архивами в формате .7Z и строка, обозначающая дату создания последнего
из архивов, в формате «ГГГГ-ММ-ДД». В результате работы скрипта файлы
должны быть переименованы в формате «Бекап_ГГГГ-ММ-ДД.7z», а
последовательность файлов должна совпадать с последовательностью, в
которой реально были созданы архивы

## [Лабораторная работа 2](lab_2/README.md)

### Задание
1. Установить ПО виртуальных машин VirtualBox или VMWare
(возможно другое по согласованию с преподавателем) на локальный
компьютер.
2. Создать две виртуальные машины.
3. Установить на одну из виртуальных машин бесплатную
ознакомительную версию Windows 11 Enterprise (возможна другая по
согласованию с преподавателем).
4. Установить на вторую виртуальную машину дистрибутив ОС
семейства Linux в соответствии с вариантом.
5. Поставить в ОС, работающих внутри обеих виртуальных машин, набор
драйверов VirtualBox Guest Additions / VMWare Tools (в соответствии с
используемым гипервизором).
6. Для виртуальной машины с ОС Windows настроить подключение к
сети Интернет, настроить подключение физического USB-устройства
(например, флешки с дистрибутивом клиента компьютерной игры).
7. Настроить между виртуальной машиной с ОС Linux и главной ОС
общую папку для передачи файлов, двусторонний буфер обмена,
двунаправленную функцию Drag'n'Drop.
8. Настроить сетевое взаимодействие между двумя виртуальными
машинами (достаточно статических IP-адресов).
9. Установить и запустить на одной виртуальной машине (Linux) сервер
игры (предпочтительно из репозиториев выбранного дистрибутива).
10. Установить и запустить на виртуальной машине с ОС Windows клиент
компьютерной игры (предпочтительно с подключенной флешки в п. 6)
11. Подключиться установленным в виртуальной машине с ОС Windows
игровым клиентом к созданному в виртуальной машине с ОС Linux
серверу и продемонстрировать работоспособность сетевого соединения
посредством краткой игровой сессии (1-2 минуты).
12. Каждый шаг зафиксировать в скринкаст

#### [Выполнение 2 лабораторной работы](https://youtu.be/uwVJdTbo1_o)

## [Лабораторная работа 3](lab_3/README.md)

### Задание
Необходимо разработать приложение, которое при помощи чистого WinAPI будет создавать окно, обрабатывать клики
мыши и нажатия клавиш, а также сохранять свое состояние и восстанавливать его при последующем запуске.

  &emsp;• По умолчанию окно размером 320 на 240 px должно быть закрашено синим цветом с красной сеткой линий NxN.<br>
  &emsp;• Размер поля (переменная N) по умолчанию выбирается на усмотрение программиста. Однако, пользователь
имеет возможность переопределить размер поля, указав его в качестве аргумента командной строки при запуске
приложения.<br>
  &emsp;• Окно существует и обрабатывает события до тех пор, пока пользователь не закрыл его. При закрытии окна
происходит завершение приложения.<br>
  &emsp;• При клике левой клавишей мыши на поле должен быть нарисован круг определенного цвета в той ячейке поля, в
&emsp;которую произошел клик.<br>
  &emsp;• При клике правой клавишей мыши на поле должен быть нарисован крестик определенного цвета в той ячейке поля,
в которую произошел клик. Цвет элементов поля (крестиков и кружков) выбирается на усмотрение программиста.<br>
  &emsp;• Если пользователь нажал на клавиатуре Ctrl+Q или ESC, окно должно закрыться.<br>
  &emsp;• Если пользователь нажал на клавиатуре Shift+C, должен запуститься блокнот.<br>
  &emsp;• Если пользователь нажал ENTER, фоновый цвет поля должен измениться на случайный.<br>
  &emsp;• При прокрутке пользователем колеса мыши текущий цвет линий сетки должен плавно изменяться.<br>
  
Смену цвета фона необходимо организовать при помощи подмены кисти окна. Использование сообщения WM_PAINT
для данной подзадачи не предполагается.
Предпочтительно реализовывать приложение на C/C++, однако допустимо использование любого языка программирования по согласованию с преподавателем и при условии соблюдения следующих двух пунктов:

  1. Использование чистого WinAPI без всяких оберток (FFI, типа питоньего ctypes, не в счет).
  2. Ручное управление ресурсами в рамках задания лабораторной, то есть не забывать делать DeleteObject и т.п.
"Здесь это делать не нужно, среда сама сделает" - не катит. Все, что в задание не входит (отладочный вывод,
дополнительные навороты), можно пользовать как угодно, лишь бы программа работала корректно.
Приложение должно использовать функции WinAPI там, где это возможно. Если эквивалентные функции есть в
стандартной библиотеке выбранного языка программирования и в WinAPI, необходимо использовать функцию WinAPI.

### Критерии оценивания лабораторной работы
Само собой предполагается, что студент безупречно разбирается в коде программы и может ответить на вопросы по
деталям реализации и особенностям работы приложения.

&emsp;• Программа реагирует на события мыши и меняет цвет линий в соответствии с заданием - 5 баллов<br>
&emsp;• Программа реагирует на события клавиатуры и выполняет действия в соответствии с заданием - 4 балла<br>
&emsp;• Окно программы адекватно реагирует на операции сворачивания, изменения размера и т.п., производя перерисовку
без лагов - 4 балла<br>
&emsp;• Программа обрабатывает параметр командной строки - 2 балла<br>
&emsp;• Программа корректно использует и утилизирует ресурсы (все ресурсы)- 3 балла<br>
&emsp;• Программа работает стабильно, не падает и не зависает - 2 балла<br>
<br><br>
##### P.S. В файле [main.cpp](main.cpp) находится 3 и 4 лабораторная работа сразу

## [Лабораторная работа 4](lab_4/README.md)

### Задание
На основе предыдущей лабораторной работы реализовать чтение/запись конфигурационного файла программы, в
котором будут храниться следующие настройки:

&emsp;• Размер поля.<br>
&emsp;• Размер окна.<br>
&emsp;• Цвет фона и цвет линий сетки.<br>

Файл должен считываться при запуске программы и записываться (актуализироваться) по ее завершению. Формат
хранения настроек определяется программистом (например, можно взять формат INI, или просто записать значения в
отдельных строках, а то и вовсе напрямую записывать и считывать структуру данных). Файл должен быть расположен
в одном каталоге с исполняемым файлом, выбор имени файла настроек - на усмотрение программиста.
При первом запуске (когда конфигурационного файла еще нет) программа должна корректно обработать эту ситуаццию,
выбрав для всех параметров указанные в задании лабораторной №3 умолчания.

Чтение/запись конфигурационного файла должна осуществляться 4 разными методами:

&emsp;• При помощи отображения файлов на память (CreateFileMapping/MapViewOfFile)<br>
&emsp;• При помощи файловых переменных (fopen / fread / fwrite / fclose).<br>
&emsp;• При помощи потоков ввода-вывода (fstream).<br>
&emsp;• При помощи файловых функций WinAPI/NativeAPI.<br>

Выбор способа загрузки должен осуществляться по наличию/отсутствию определённого аргумента командной строки
при запуске приложения.

Размер поля, указанный пользователем при запуске приложения в качестве аргумента командной строки, имеет
приоритет над значением, записанным в конфигурационном файле, и значением по умолчанию.

### Критерии оценивания

&emsp;• Программа корректно реализует чтение/запись при помощи отображения на память - 2 балла.<br>
&emsp;• Программа корректно реализует чтение/запись при помощи файловых переменных - 1 балл.<br>
&emsp;• Программа корректно реализует чтение/запись при помощи потоков - 1 балл.<br>
&emsp;• Программа корректно реализует чтение/запись при помощи файловых функций WinAPI/NativeAPI - 1 балл.<br>
&emsp;• Программа принимает и корректно обрабатывает параметр командной строки, отвечающий за метод загрузки
конфигурационного файла - 1 балл.<br>
&emsp;• Программа корректно реализует логику определения размера окна с учетом значения из конфигурационного
файла и параметра командной строки - 2 балла.<br>
&emsp;• Студент может аргументированно объяснить, в чём заключается разница между используемыми методами
чтения/записи файла - 2 балла.<br>

Под корректностью реализации подразумевается в т.ч. своевременное освобождение ресурсов

## [Лабораторная работа 5](lab_6/README.md)

### Задание
1. Ознакомиться с теоретическим материалом для данной работы.
2. Изучить предложенные демонстрационные примеры многопоточных приложений, использующие механизм
взаимного исключения: задача об обедающих философах (phil.cpp) и задача читателей-писателей (rw.cpp).
3. Быть готовым ответить на вопросы по "Войне потоков" (WarThreads.cpp). Примерный (но далеко не полный!)
список тем:
&emsp;• Общая архитектура решения;<br>
&emsp;• Реализация отложенного старта игры;<br>
&emsp;• Механизм генерации пуль;<br>
&emsp;• Механизм генерации противников;<br>
&emsp;• Механизм разделения доступа к общему ресурсу - буферу консоли;<br>
&emsp;• ...<br>
&emsp;• Реализация завершения игры.<br>

### Замечания
При желании, "Война потоков" может быть переписана на любом предпочитаемом ЯП с нативной поддержкой потоков,
примитивов синхронизации и прочих необходимых инструментов. В этом случае вопросы будут задаваться с учетом
реализации; кроме того, при хорошем уровне работы возможны бонусы в виде дополнительных баллов.

### Запуск "Войны потоков"
Внутри каталога .build в соответствующих подкаталогах лежат проекты для MSVS 2010, MSVS 2012 и MSVS 2015.
Если по каким-то причинам эти проекты не устраивают/не работают/не подходят, возможны следующие варианты:
&emsp;• Продвинутый вариант: скачать утилиту premake5, поправить premake5.lua и выполнить команду premake5
<название_цели>.
&emsp;• Более простой вариант: создать пустой проект WinAPI в вашей IDE (MSVS, Code::Blocks, ...) и импортировать
туда файл WarThreads.cpp.
Само приложение, разумеется, реализовано на чистом WinAPI без использования возможностей C++, поэтому
практически без изменений может быть скомпилировано Сишным компилятором (достаточно сменить расширение
файла).

### Критерии оценивания
&emsp;• Вопросы по семафорам - 1 балл<br>
&emsp;• Вопросы по мютексам - 1 балл<br>
&emsp;• Вопросы по критическим секциям - 1 балл<br>
&emsp;• Вопросы по атомарным операциям - 1 балл<br>
&emsp;• Общие вопросы - 1 балл<br>


## [Лабораторная работа 6](lab_6/README.md)

### Задание
1. Ознакомиться с теоретическим материалом для данной работы.
2. Изучить предложенные демонстрационные примеры многопоточных приложений, использующие механизм
взаимного исключения: задача об обедающих философах (phil.cpp) и задача читателей-писателей (rw.cpp).
3. Быть готовым ответить на вопросы по "Войне потоков" (WarThreads.cpp). Примерный (но далеко не полный!)
список тем:
&emsp;• Общая архитектура решения;<br>
&emsp;• Реализация отложенного старта игры;<br>
&emsp;• Механизм генерации пуль;<br>
&emsp;• Механизм генерации противников;<br>
&emsp;• Механизм разделения доступа к общему ресурсу - буферу консоли;<br>
&emsp;• ...<br>
&emsp;• Реализация завершения игры.<br>

### Замечания
При желании, "Война потоков" может быть переписана на любом предпочитаемом ЯП с нативной поддержкой потоков,
примитивов синхронизации и прочих необходимых инструментов. В этом случае вопросы будут задаваться с учетом
реализации; кроме того, при хорошем уровне работы возможны бонусы в виде дополнительных баллов.

### Запуск "Войны потоков"
Внутри каталога .build в соответствующих подкаталогах лежат проекты для MSVS 2010, MSVS 2012 и MSVS 2015.
Если по каким-то причинам эти проекты не устраивают/не работают/не подходят, возможны следующие варианты:
&emsp;• Продвинутый вариант: скачать утилиту premake5, поправить premake5.lua и выполнить команду premake5
<название_цели>.
&emsp;• Более простой вариант: создать пустой проект WinAPI в вашей IDE (MSVS, Code::Blocks, ...) и импортировать
туда файл WarThreads.cpp.
Само приложение, разумеется, реализовано на чистом WinAPI без использования возможностей C++, поэтому
практически без изменений может быть скомпилировано Сишным компилятором (достаточно сменить расширение
файла).

### Критерии оценивания
&emsp;• Вопросы по семафорам - 1 балл<br>
&emsp;• Вопросы по мютексам - 1 балл<br>
&emsp;• Вопросы по критическим секциям - 1 балл<br>
&emsp;• Вопросы по атомарным операциям - 1 балл<br>
&emsp;• Общие вопросы - 1 балл<br>


## [Лабораторная работа 7](lab_7/README.md)

### Задание
Выполнение лабораторной работы предполагается на основании предыдущих лабораторных работ.
Студенту необходимо вынести отрисовку поля в отдельный поток, анимировав отрисовку фона (например, при помощи
переливающегося градиента). Должна быть реализована возможность устанавливать приоритет потока отрисовки
путем нажатия цифровых клавиш (например, 1 для установки фонового приоритета, 2 - низшего и т.д.). По нажатию
клавиши "пробел" поток отрисовки должен приостанавливать и возобновлять свое выполнение.

Также необходимо реализовать механику игры. Следует добавить:

&emsp;• механизм выбора "команды" игрока при запуске очередного экземпляра приложения (каждое окно является
отдельным "игроком", который может манипулировать только своими игровыми объектами);<br>
&emsp;• ограничение на количество игроков, вытекающее из логики игры;<br>
&emsp;• различные визуальные маркеры для объектов каждого из игроков (крестики/нолики, черные/белые фишки и
т.п.);<br>
&emsp;• механизм исключения хода (игроки должны ходить по очереди в строгой последовательности в соответствии с
логикой игры).<br>

При попытке сходить в чужой ход должно выдаваться сообщение об ошибке. После каждого хода должна выполняться
проверка состояния игрового поля на предмет выполнения условий завершения (построение линии из N элементов для
крестиков-ноликов, заполнение поля фишками для реверси и т.п.) и определяться игрок-победитель, о чем следует
выдавать соответствующее сообщение. После закрытия этого сообщения процесс должен корректно завершаться,
подчищая за собой все ресурсы. Последний из завершающихся процессов должен также очистить игровое поле и
удалить все разделяемые ресурсы.

### Замечание
По выходу из программы все ресурсы должны корректно освобождаться, фраза "ОС/среда подчистит всё за нас" (c)
не принимается.

### Критерии оценивания
&emsp;• Рабочий механизм установки приоритета потока - 3 балла<br>
&emsp;• Поток отрисовки приостанавливается и возобновляется - 2 балла<br>
&emsp;• Рабочий механизм анимации с использованием многопоточности - 4 балла<br>
&emsp;• Обработка очередности хода - 4 балла<br>
&emsp;• Обработка условия завершения игры, освобождение ресурсов - 3 балла<br>
&emsp;• Программа работает стабильно, нормально завершается, грамотно управляет ресурсами - 4 балла<br>
